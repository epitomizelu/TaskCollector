name: EAS Build Android Preview (Cloud Upload)

on:
  workflow_dispatch:  # 仅手动触发

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          # 确保有写权限，以便推送版本号更新

      - name: Setup Node.js (Cache Disabled - Fix 408 Timeout)
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          # cache: 'npm'  # 临时禁用，避免 GitHub 缓存服务 408 错误

      - name: Install dependencies
        run: npm ci  # 更快安装，无缓存依赖

      - name: Update version for APK build
        id: version
        run: |
          echo "更新版本号（APK 构建）..."
          node scripts/update-version.js --type build
          echo "版本号更新完成"
          # 读取更新后的版本号
          VERSION=$(node -p "require('./app.json').expo.version")
          VERSION_CODE=$(node -p "require('./app.json').expo.android.versionCode")
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "versionCode=$VERSION_CODE" >> $GITHUB_OUTPUT
          echo "新版本: v$VERSION (Build $VERSION_CODE)"

      - name: Commit version update
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add app.json
          git commit -m "chore: 自动更新版本号 [skip ci]" || echo "没有版本变更或已是最新"
          # 推送到当前分支（通常是 main）
          git push origin HEAD:${{ github.ref_name }} || echo "推送失败或无需推送"
          echo "✅ 版本号已提交到分支: ${{ github.ref_name }}"

      - name: Setup EAS CLI
        uses: expo/expo-github-action@v8
        with:
          eas-version: latest
          token: ${{ secrets.EXPO_TOKEN }}
          # expo-cache: false  # 禁用 Expo CLI 缓存（可选）

      - name: Verify EAS Configuration
        run: |
          echo "========== 检查 EAS 配置 =========="
          # 检查 eas.json 是否存在
          if [ ! -f "eas.json" ]; then
            echo "❌ eas.json 文件不存在"
            exit 1
          fi
          echo "✅ eas.json 文件存在"
          
          # 检查 app.json 中的项目配置
          echo "检查 app.json 配置..."
          node -e "
            const fs = require('fs');
            const appJson = JSON.parse(fs.readFileSync('app.json', 'utf8'));
            console.log('项目名称:', appJson.expo.name);
            console.log('项目 Slug:', appJson.expo.slug);
            console.log('项目版本:', appJson.expo.version);
            console.log('Android Package:', appJson.expo.android?.package);
            console.log('Android VersionCode:', appJson.expo.android?.versionCode);
            if (appJson.expo.extra?.eas?.projectId) {
              console.log('EAS Project ID:', appJson.expo.extra.eas.projectId);
            }
          "
          
          # 验证 EAS CLI 认证状态
          echo "检查 EAS CLI 认证状态..."
          eas whoami || echo "⚠️ 无法获取用户信息（可能需要在构建时验证）"
          
          echo "=================================="

      - name: Run EAS Build with Retry
        env:
          # 从 GitHub Secrets 读取 API Key
          EXPO_PUBLIC_API_KEY: ${{ secrets.EXPO_PUBLIC_API_KEY }}
        id: build
        run: |
          # 注意：不使用 set -e，因为我们需要手动处理错误
          set -o pipefail  # 管道命令中任何命令失败都会导致整个管道失败
          
          # 动态替换 eas.json 中的 ${EXPO_PUBLIC_API_KEY} 为实际值
          # 因为 EAS Build 在 GitHub Actions 中不会自动从 EAS Secrets 读取
          if [ -n "$EXPO_PUBLIC_API_KEY" ]; then
            echo "替换 eas.json 中的 API Key..."
            echo "API Key 长度: ${#EXPO_PUBLIC_API_KEY}"
            echo "API Key 前缀: ${EXPO_PUBLIC_API_KEY:0:8}..."
            
            # 使用 Node.js 脚本来安全地替换 eas.json 中的占位符
            # 这样可以正确处理 API Key 中的特殊字符
            if node -e "
              const fs = require('fs');
              const apiKey = process.env.EXPO_PUBLIC_API_KEY;
              const easJson = JSON.parse(fs.readFileSync('eas.json', 'utf8'));
              
              // 替换 preview 和 production 配置中的占位符
              if (easJson.build?.preview?.env?.EXPO_PUBLIC_API_KEY === '\${EXPO_PUBLIC_API_KEY}') {
                easJson.build.preview.env.EXPO_PUBLIC_API_KEY = apiKey;
              }
              if (easJson.build?.production?.env?.EXPO_PUBLIC_API_KEY === '\${EXPO_PUBLIC_API_KEY}') {
                easJson.build.production.env.EXPO_PUBLIC_API_KEY = apiKey;
              }
              
              fs.writeFileSync('eas.json', JSON.stringify(easJson, null, 2));
              console.log('✅ eas.json 已更新');
            "; then
              # 验证替换是否成功
              if grep -q "\"$EXPO_PUBLIC_API_KEY\"" eas.json; then
                echo "✅ 验证成功: eas.json 中的 API Key 已正确替换"
              else
                echo "⚠️ 警告: eas.json 中的 API Key 替换可能失败，但继续构建"
              fi
            else
              echo "⚠️ 警告: eas.json 更新失败，但继续构建"
            fi
            
            # 同时将 API Key 注入到 app.json 的 extra.apiKey 字段（作为备用方案）
            # 使用 Node.js 脚本来安全地修改 JSON
            if node -e "
              const fs = require('fs');
              const appJson = JSON.parse(fs.readFileSync('app.json', 'utf8'));
              if (!appJson.expo.extra) appJson.expo.extra = {};
              appJson.expo.extra.apiKey = process.env.EXPO_PUBLIC_API_KEY || '';
              fs.writeFileSync('app.json', JSON.stringify(appJson, null, 2));
              console.log('✅ app.json 中的 API Key 已注入');
            "; then
              # 打印 app.json 的 extra 部分内容
              echo ""
              echo "=== app.json extra 部分内容 ==="
              node -e "
                const fs = require('fs');
                const appJson = JSON.parse(fs.readFileSync('app.json', 'utf8'));
                console.log(JSON.stringify(appJson.expo.extra, null, 2));
              "
            else
              echo "⚠️ 警告: app.json 更新失败，但继续构建"
            fi
          else
            echo "⚠️ 警告: EXPO_PUBLIC_API_KEY 环境变量未设置"
          fi
          
          # 重试逻辑：如果构建失败，自动重试（最多3次）
          BUILD_SUCCESS=false
          BUILD_OUTPUT_FILE=$(mktemp)
          set +e  # 在整个重试循环中禁用错误退出，以便处理重试逻辑
          
          for i in {1..3}; do
            echo "========== 构建尝试 $i/3 =========="
            # 通过环境变量传递 API Key，确保 EAS Build 能够读取
            export EXPO_PUBLIC_API_KEY="$EXPO_PUBLIC_API_KEY"
            
            # 运行 eas build，将输出同时显示在终端和保存到文件
            # 使用 tee 来同时输出到终端和文件，以便后续提取 URL
            EXPO_PUBLIC_API_KEY="$EXPO_PUBLIC_API_KEY" eas build --platform android --profile preview --non-interactive 2>&1 | tee "$BUILD_OUTPUT_FILE"
            BUILD_EXIT_CODE=${PIPESTATUS[0]}  # 获取第一个命令（eas build）的退出代码
            
            # 读取构建输出（即使失败也要读取，以便显示错误信息）
            BUILD_OUTPUT=$(cat "$BUILD_OUTPUT_FILE" 2>/dev/null || echo "")
            
            if [ $BUILD_EXIT_CODE -eq 0 ]; then
              echo "✅ 构建命令执行成功！"
              
              # 提取下载 URL（使用正则匹配，支持任意文件名）
              # 格式：https://expo.dev/artifacts/eas/<随机字符串>.apk
              DOWNLOAD_URL=$(echo "$BUILD_OUTPUT" | grep -oE 'https://expo\.dev/artifacts/eas/[a-zA-Z0-9]+\.apk' | head -1)
              
              if [ -z "$DOWNLOAD_URL" ]; then
                # 备用方法1：匹配包含 "Android app:" 的行
                DOWNLOAD_URL=$(echo "$BUILD_OUTPUT" | grep -i "android app" | grep -oE 'https://expo\.dev/artifacts/eas/[a-zA-Z0-9]+\.apk' | head -1)
              fi
              
              if [ -z "$DOWNLOAD_URL" ]; then
                # 备用方法2：从构建输出中查找包含 .apk 的完整 URL
                DOWNLOAD_URL=$(echo "$BUILD_OUTPUT" | grep -oE 'https://expo\.dev/[^ ]+\.apk' | head -1)
              fi
              
              if [ -n "$DOWNLOAD_URL" ]; then
                echo "download_url=$DOWNLOAD_URL" >> $GITHUB_OUTPUT
                echo "✅ APK 下载地址: $DOWNLOAD_URL"
                BUILD_SUCCESS=true
                rm -f "$BUILD_OUTPUT_FILE"
                break
              else
                echo "⚠️  警告: 无法从构建输出中提取 APK 下载地址"
                echo "构建可能成功但 URL 未在输出中显示（可能是异步构建）"
                echo "构建输出中的关键信息:"
                echo "$BUILD_OUTPUT" | grep -iE "build|android|apk|artifact|success|complete|url" | tail -20
                # 即使没有提取到 URL，如果构建命令成功，也标记为成功
                # EAS Build 可能是异步的，URL 可能稍后才可用
                BUILD_SUCCESS=true
                rm -f "$BUILD_OUTPUT_FILE"
                break
              fi
            else
              echo "❌ 构建尝试 $i 失败，退出代码: $BUILD_EXIT_CODE"
              
              # 显示错误信息
              echo "========== 构建错误信息 =========="
              echo "$BUILD_OUTPUT" | grep -iE "error|fail|exception|timeout|unauthorized|invalid" | tail -30
              echo "=================================="
              
              if [ $i -lt 3 ]; then
                echo "等待 30 秒后重试..."
                sleep 30
              else
                echo "❌ 所有构建尝试都失败了"
                echo "========== 完整的构建输出（最后 100 行）=========="
                echo "$BUILD_OUTPUT" | tail -100
                echo "================================================"
                rm -f "$BUILD_OUTPUT_FILE"
                exit 1
              fi
            fi
          done
          
          # 清理临时文件
          rm -f "$BUILD_OUTPUT_FILE"
          
          # 重新启用错误退出
          set -e
          
          # 最终检查：如果构建失败，退出
          if [ "$BUILD_SUCCESS" != "true" ]; then
            echo "❌ EAS 构建失败：所有重试尝试都失败了"
            echo "请检查上面的错误信息，常见问题包括："
            echo "  1. EAS Token 无效或过期（检查 secrets.EXPO_TOKEN）"
            echo "  2. 项目配置错误（检查 app.json 和 eas.json）"
            echo "  3. 网络问题或 Expo 服务问题"
            echo "  4. 构建配额不足"
            exit 1
          fi
          
          echo "✅ 构建步骤完成"

      - name: Display Version Info
        if: success() && steps.build.outputs.download_url != ''
        run: |
          # 版本号已在构建前更新，这里只显示
          VERSION="${{ steps.version.outputs.version }}"
          VERSION_CODE="${{ steps.version.outputs.versionCode }}"
          echo "当前版本: v$VERSION (Build $VERSION_CODE)"

      - name: Save Version Info (EAS URL)
        if: success() && steps.build.outputs.download_url != ''
        env:
          API_BASE_URL: https://cloud1-4gee45pq61cd6f19-1259499058.ap-shanghai.app.tcloudbase.com/task-collection-api
          EXPO_PUBLIC_API_KEY: ${{ secrets.EXPO_PUBLIC_API_KEY }}
        run: |
          echo "保存版本信息到数据库（EAS URL）..."
          DOWNLOAD_URL="${{ steps.build.outputs.download_url }}"
          node scripts/save-version-info.js "$DOWNLOAD_URL"
          echo "✅ 版本信息已保存，即使后续上传失败，也可以从 EAS 下载 APK"

      - name: Cloud Function Download and Upload
        if: success() && steps.build.outputs.download_url != '' && steps.version.outputs.version != ''
        env:
          API_BASE_URL: https://cloud1-4gee45pq61cd6f19-1259499058.ap-shanghai.app.tcloudbase.com/task-collection-api
          EXPO_PUBLIC_API_KEY: ${{ secrets.EXPO_PUBLIC_API_KEY }}
        run: |
          echo "调用云函数下载并上传 APK..."
          DOWNLOAD_URL="${{ steps.build.outputs.download_url }}"
          VERSION="${{ steps.version.outputs.version }}"
          VERSION_CODE="${{ steps.version.outputs.versionCode }}"
          
          echo "参数:"
          echo "  EAS URL: $DOWNLOAD_URL"
          echo "  版本: v$VERSION (Build $VERSION_CODE)"
          
          # 调用云函数接口
          node -e "
            const https = require('https');
            const apiKey = process.env.EXPO_PUBLIC_API_KEY;
            const apiBaseUrl = process.env.API_BASE_URL;
            const easUrl = process.argv[2];
            const version = process.argv[3];
            const versionCode = parseInt(process.argv[4], 10);
            
            const requestData = JSON.stringify({
              easDownloadUrl: easUrl,
              version: version,
              versionCode: versionCode,
              platform: 'android'
            });
            
            const url = new URL(apiBaseUrl + '/app/download-and-upload');
            const options = {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': 'Bearer ' + apiKey,
                'Content-Length': Buffer.byteLength(requestData)
              },
              timeout: 300000  // 5分钟超时（大文件下载和上传需要时间）
            };
            
            console.log('发送请求到:', url.toString());
            
            const req = https.request(url, options, (res) => {
              let data = '';
              res.on('data', (chunk) => { data += chunk; });
              res.on('end', () => {
                try {
                  const result = JSON.parse(data);
                  if (res.statusCode === 200 && result.code === 0) {
                    console.log('✅ 云函数下载并上传成功');
                    console.log('文件路径:', result.data.filePath);
                    console.log('文件 URL:', result.data.fileUrl);
                    console.log('文件大小:', (result.data.fileSize / 1024 / 1024).toFixed(2), 'MB');
                    process.exit(0);
                  } else {
                    console.error('❌ 云函数返回错误:', result.message || '未知错误');
                    console.error('响应:', JSON.stringify(result, null, 2));
                    process.exit(1);
                  }
                } catch (e) {
                  console.error('❌ 解析响应失败:', e.message);
                  console.error('原始响应:', data);
                  process.exit(1);
                }
              });
            });
            
            req.on('error', (error) => {
              console.error('❌ 请求失败:', error.message);
              process.exit(1);
            });
            
            req.on('timeout', () => {
              req.destroy();
              console.error('❌ 请求超时（5分钟）');
              process.exit(1);
            });
            
            req.write(requestData);
            req.end();
          " "$DOWNLOAD_URL" "$VERSION" "$VERSION_CODE"
          echo "✅ APK 上传成功，版本号已自动更新并提交到 Git"
      
      - name: Verify Version Update
        if: success() && steps.build.outputs.download_url != '' && steps.version.outputs.version != ''
        run: |
          echo "验证版本号更新..."
          VERSION="${{ steps.version.outputs.version }}"
          VERSION_CODE="${{ steps.version.outputs.versionCode }}"
          CURRENT_VERSION=$(node -p "require('./app.json').expo.version")
          CURRENT_VERSION_CODE=$(node -p "require('./app.json').expo.android.versionCode")
          
          if [ "$CURRENT_VERSION" = "$VERSION" ] && [ "$CURRENT_VERSION_CODE" = "$VERSION_CODE" ]; then
            echo "✅ 版本号验证通过: v$CURRENT_VERSION (Build $CURRENT_VERSION_CODE)"
          else
            echo "⚠️  警告: 版本号不一致"
            echo "  期望: v$VERSION (Build $VERSION_CODE)"
            echo "  实际: v$CURRENT_VERSION (Build $CURRENT_VERSION_CODE)"
          fi

      - name: Upload Build Artifact (If Success)
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: android-app-cloud-upload
          path: |
            *.aab
            *.apk
          retention-days: 7
          if-no-files-found: ignore

